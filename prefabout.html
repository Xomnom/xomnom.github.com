<html>
<head><title>How Preference Revealer Works</title></head>
<body>
<p><b>This page is obsolete.<br>
<a href="preference.html">Go to the current version of Preference Revealer.</a><br>
See also:  <a href="https://github.com/Xomnom/Preference-Revealer">Preference Revealer on GitHub.</a></b></p>
<font color="grey">
<p>--</p>
<h2>How <a href="preference.html">Preference Revealer</a> Works</h2>
<p>From the about blurb:
<blockquote><h6><p><a href="preference.html">Preference Revealer</a> sorts a list of items by asking the user to make pairwise comparisons.  It is inspired by <a href="http://mainyan.sakura.ne.jp/thsort.html">T&#333;h&#333;</a> <a href="http://freewebs.com/tohosort">Sort</a>.  Hat tip to pluffei for suggesting a general-purpose version.  Many thanks to Knuth for his in-depth discussion of minimal-comparison sorting.</p><p>Unlike T&#333;h&#333; Sort, which uses merge sort, Preference Revealer uses the Ford-Johnson algorithm, a.k.a. merge insertion, as described in Knuth's <i>The Art of Computer Programming, vol. 3: Sorting and Searching</i>.  Its worst-case makes fewer comparisons than merge sort's.  According to my rather hasty calculations, its average-case also tends to make one or two percent fewer.  Naturally, it probably can't beat most merge sort implementations' best-case (i.e. minimum) comparisons.  Its overhead makes it unsuitable for most practical applications.  See Knuth for details on the algorithm.</p><p>To make it easy to toy with and modify, all the code is contained in the HTML file.</p><a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width: 0pt;" src="http://i.creativecommons.org/l/by/3.0/80x15.png"></a> <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Preference Revealer</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://xomnom.com" property="cc:attributionName" rel="cc:attributionURL">Xomnom</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.</h6></blockquote></p>
<p>I've never really done any web development.  That said, when my friend showed me T&#333;h&#333; Sort, and suggested generalizing it, I thought to myself:  Hey, this is the sort of thing I'd screw around with when I was done with my work for my middle school newspaper, back when Javascript was a novelty.  So I set out to pretend for a bit that I was back in newspaper class, but with a few amenities from the twenty-first century (i.e. Wikipedia).</p>
<p>When I looked up merge sort to check whether it was the best choice when comparison count is all that matters, I found that it was, but only of the algorithms with top-level English Wikipedia pages.  Binary insertion sort, described among the variants of insertion sort, has a more efficient worst-case (I haven't really thought about the average-case).  More mysteriously, the comparison sort page mentioned, but did not describe, a certain Ford-Johnson algorithm.</p>
<p>Some remarks on the algorithm's performance are above.  Here I'll describe enough of the algorithm to determine it, but again, see Knuth for details on the algorithm.</p>
<blockquote><p>First, we group all the items into pairs, and compare each pair to find the higher item; there may be an odd one out, which we'll get back to.</p>
<p>Then, we recur the algorithm to sort the pairs by their higher items.  After that finishes, call the sequence of higher items the main chain; its elements are initially a<sub>1</sub> through a<sub>k</sub>, where a<sub>k</sub> is the highest of the higher items.</p>
<p>It remains to insert the lower items into the main chain using binary insertion.</p>
<p>We'll continue to call the higher items as a<sub>1</sub> through a<sub>n</sub> regardless of shifts in position.  We'll call the corresponding lower items b<sub>1</sub> through b<sub>n</sub>.  For each b<sub>i</sub>, the lowest possible insertion position is at the bottom, and the highest is right under a<sub>i</sub>, wherever that happens to be.  So if we had an odd item, it makes sense now to call it b<sub>n+1</sub>, befitting where it could possibly be inserted.</p>
<p>It turns out that a very efficient ordering is to insert b<sub>1</sub> for free, then insert as many items as possible for at most two comparisons each (b<sub>3</sub> then b<sub>2</sub>, because after b<sub>2</sub> it might cost three for b<sub>3</sub>), then as many as possible for at most three each (b<sub>5</sub> then b<sub>4</sub>), then for four (b<sub>11</sub> down to b<sub>6</sub>), and so on, skipping nonexisting b<sub>i</sub>, until done.</p></blockquote>
<p>To check your understanding of the algorithm, try following along on pencil and paper.  Optionally, you can save the file locally and comment out the one-liner that shuffles the initial input.</p>
<p>Being a fan of <a href="http://baen.com/library/0671878468/0671878468.htm">Wiz Zumwalt</a>, I rolled my own stack of tokens to track state across user inputs.  I started out with thoughts of using my little stack for as much of the logic as possible, but I mellowed out and now some of the coordination lives in the stack and some of it lives in auxiliary variables.</p>
<p>The other tricky portion is the code that keeps track of where the a<sub>i</sub> get shifted.  A conservative estimate would preserve the worst-case performance, but by updating the highest possible insertion position based on where the previous insertions actually go, a few comparisons can be spared here and there, which presumably also is presumed by Knuth when he calculates the average-case.</p>
<p>One last morsel for those who read this far:  Try clicking [<u>example</u>] twice.</p>
<p><h6><a href="http://xomnom.com">Xomnom</a><br>2012-2-14</h6></p>
</font>
</body>
</html>
